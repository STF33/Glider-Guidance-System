Abstract:

	The Glider Guidance System (GGS) is a diverse toolbox designed to assist in the navigational complexities associated with flying underwater autonomous underwater vehicles (AUVs). Specifically, GGS was developed for use with Slocum gliders developed by Teledyne Marine's Webb Research lab.
	
	Slocum gliders fly through the water column in a wave-like pattern called a 'yo'. A single yo consists of:
		1. An initial 'surface' interval
		2. A 'dive' interval
		3. A 'hover' interval
		4. A 'climb' interval
		5. A final 'surface interval
	Gliders achieve flight in this yo pattern by dynamically changing its buoyancy in the water to either become negatively buoyant and sink  or positively buoyant and float. This physical change is facilitated by a ballast pump in the gliders nose cone which can intake sea water (decreasing the volume of its inner fuselage, thus making it denser and less buoyant) or eject sea water (increasing the volume of its inner fuselage, making it less dense and more buoyant). In order to gain forward momentum from the vertical motion provided by the buoyancy, the glider has wings which convert some of the vertical velocity into angular horizontal velocity.
	
	Currently, flight planning for these gliders is particularly difficult as ocean conditions (particularly currents) are highly variable across space and time and further have a large impact on the flight dynamics of AUVs. In order to combat this and improve mission planning efficiency, the Glider Guidance System seeks to provide the following tools to pilots:
		1. Create a mission name from the name of the glider being used, provide by user input
			i. Mission name should be saved as 'GGS_[date]_[glider name]'
		2. Receive user input on starting glider deployment location (latitude and longitude)
		3. Receive user input on set waypoints (latitude and longitude) which the glider will reach
		4. Receive user input on the intended endpoint (latitude and longitude) for the gliders mission
		5. Create a flight path region consisting of a 10 kilometer zone centered upon the route lines created between the starting point, waypoints, and endpoints of the gliders flight track
		6. Pull ocean model data for forecasted ocean currents in the identified flight path region for a depth range of 0-1000 meters, binned into 50-meter stretches for a total of 20 bins consisting of depth ranges: 
			i. [(0.5, 50), (50, 100), (100, 150), (150, 200), (200, 250), (250, 300), (300, 350), (350, 400), (400, 450), (450, 500), (500, 550), (550, 600), (600, 650), (650, 700), (700, 750), (750, 800), (800, 850), (850, 900), (900, 950), (950, 1000), (1000, 1050)]
			ii. Additionally, a full depth (0.5-1000) meter depth bin should be made for general case usage
		7. Display the currents in the flight path region on a map with the boundaries of the flight path region shown in addition to the designated starting point, waypoints, and endpoint
		8. Utilize a particle advection model to simulate the gliders movement in the forecasted currents
	While this toolbox will certainly expand upon its capabilities with time and development, these features are the most critical and will serve as the backbone for the project.
	
Python Coding Environment Setup:
	
	The currently identified python packages needed for this project are:
		1. cartopy
		2. cf_xarray
		3. cmocean
		4. dask
		5. erddapy
		6. matplotlib
		7. netcdf4
		8. numba
		9. numpy
		10. pandas
		11. parcels (ocean parcels)
		12. scipy
		13. seaborn
		14. seawater
		15. xarray
		16. xgcm
		17. xroms
	
	The code should perform the following actions accordingly:
		1. Import all necessary packages and libraries
		2. Create a function to accept user inputs for glider configuration and route planning details such as:
			i. Glider name
			ii. Glider speed
			iii. Starting latitude
			iv. Starting longitude
			v. [Optional: any number of waypoints (latitude and longitude)]
			vi. Ending latitude
			vii. Ending Longitude
		3. Save the users inputs for mission inputs as a file in the downloads folder named ('GGS_[date]_[glider name]' which can be re-imported later if the code is rerun to prevent exhaustive/repeated user input for the same mission
			i. Note: this implies that the beginning of the code taking user inputs for route points should ask the user if they want to import an existing route or if they would like to create a new one and enter new route points manually
		4. Perform a background computation using the gliders average speed (note that the average speed is the mean velocity of the glider across all stages of the yo flight pattern, from the surface to dive to hover to climb to surface stages)
			i. This mathematical calculation of the gliders movement across the yo flight pattern should be made with the assumption that inflections in the wave-like pattern are nearly immediate and the angle of descent and ascent is 35.5 degrees to the horizontal
			ii. Keeping this data will become relevant during map plotting
		5. Plot the glider route with a 10 kilometer barrier around it onto a map and ask the user if this track is confirmed to be correct
			i. If it is confirmed, proceed
			ii. If invalidated by user, discard the inputs and return to step 2 (ask the user to re-enter all new route points and create a new mission file from it)
		6. Redraw the confirmed map with a color-gradient line depicting the anticipated date/time that the glider will reach the point in space in the graph
			i. Keeping a record of where the glider will be in space and forecasted time is important for ocean model data import in the next steps
		7. Ask the user how many days in advance they would like to forecast with respect to the current day
		8. Create a new subdivision of the glider route (including the 10 kilometer barrier previously established) which only includes the area of space which the glider will travel across in the expected time provided by the user in the last step
			i. The subdivision should contain a second level of subregions separated by which calendar date they cover in the gliders flight forecast
				1) I.e., if the user wants to forecast 3 days, there should be three subregions (one for each day)
		9. Download the ocean model forecast data for the average current velocity in each of the depth bins for the glider route subregions and save the data as a tempfile in the downloads folder called '[ocean model source]_[date]_[bin 1-20]'
			i. Note that if there are multiple subdivisions, requested forecast downloads should correspond to the date at which the glider is expected to be there at
				1) I.e., following the example used for a 3 day forecast with three subregions, a download for the ocean current data should be made for the 1st subregion corresponding to that 24-hour day, a download for the ocean current data should be made for the 2nd subregion corresponding to that 24-hour day, and a third download for the ocean current data should be made for the 3rd subregion corresponding to that 24-hour day
		10. Using the full depth bin (0.5-1000) meters, the ocean parcels package should be used to model the gliders movement in each of the subregions allotted
		11. Lastly, the script should ask if the user would like to model the gliders advection using the ocean parcel package at a specific depth bin
			i. If yes, ask for user input for which depth bin to model the Ocean Parcels package to model the glider
			ii. If no, end
	
	Things to consider for future additions:
		1. Eventually, this tool should pull ocean current data for two different global models and save their relevant datapoints for the confirmed map region separately
			i. An average of the two ocean current models should be calculated for the final model output in the tool, and a percentage error should be given to the user so they can gauge how in synchronization or how in disagreement the two models are
			ii. Additionally, checks for the ocean currents should be made by using real-time data available for the ocean region the glider is in and comparing it to both the models
				1) Depending on how accurate one model is to another, the more accurate model should be weighted more heavily when computing the final model output computer from the average of the two
					a) For example, if one model is only 30% inaccurate to the real time data and the other is 50% inaccurate, then the model with higher accuracy should be proportionally higher weighed in the final output computation compared to the other which was less accurate

